subject lga ncrypt sourc i got a number of request for code so here it is it written in x asm borland tasm will do tasm lga asm tlink t lga asm the code lga ncryption c by nick nassuphi code segment assum cs code ds code org h start jmp begin ga particl assig bit particl move east bit particl move west bit particl move north bit particl move south bit particl move east bit particl move west bit particl move north bit particl move south collisiong rule ga rule if e w and n s then e w n s if n s and e w then n s e w for nibbl and for byte reflect rule just swap bit along direct thi look up tabl implement two particl collis for the hpp lattic ga hpprule db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b thi rule implement the veloc revers need to run the ga evolut in revers it call a wallrul becaus it the same as is all particl hit a wall head on wallrul db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b db b maxbyt equ lineno equ srcptr dw offset buffer desptr dw offset buffer savebuff db maxbyt lineno dup buffer db maxbyt lineno dup db dup buffer db maxbyt lineno dup db dup data db db db db thi is a test for a lattic ga base encrypt db algorithm the data is encod as particl of a db digit ga whose time evolut is then simul db with a cellular automaton type algorithm decrypt db can be achiev by run the simul in revers db a thermodynam argument ensur that even if a singl db bit is flip no decrypt of the data is possibl db db after the ga is let to evolv for timestep db on can either run the revers evolut by press db space or flip a bit and then run by press db db for a cryptograph applic the kei would consist db of the number of time step and the time and locat db of specif bit invers db db db db db fill the ga with a piec of code initga mov di cs srcptr mov si offset data mov cx lineno ig push di push cx mov cx maxbyt ig mov al cs si mov cs di al inc si inc di loop ig pop cx pop di add di maxbyt loop ig mov si cs srcptr mov di offset initga mov cx maxbyt mov al lg mov byte ptr cs si al not al inc si loop lg ret displai ga molecul bounc around showga push es push si push di push cx push bx mov ax b h mov es ax mov si cs srcptr mov di mov cx lineno add si maxbyt sg push cx push di mov cx maxbyt sg mov al cs si mov byte ptr es di al inc si add di dec cx jnz sg pop di pop cx add di loop sg pop bx pop cx pop di pop si pop es ret cs si sours of data cs di destin of data scanonemiddlelin first byte is a special case becaus of warparound mov bl al is the assembl byte mov bh cs si maxbyt north is on line up lower and bh b and at bit and or bl bh or them into the assembl byte mov bh cs si maxbyt south is on line down higher and bh b and at bit and or bl bh place the stuff into al mov bh cs si maxbyt west is on byte left lower and bh b and at bit and or bl bh mov bh cs si east is on byte right higher and bh b and at bit and or bl bh mov bh mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di middl byte can be handl in a loop mov cx maxbyt sol mov bl al is the assembl byte mov bh cs si maxbyt north is on line up lower and bh b and at bit and or bl bh or them into the assembl byte mov bh cs si maxbyt south is on line down higher and bh b and at bit and or bl bh place the stuff into al mov bh cs si west is on byte left lower and bh b and at bit and or bl bh mov bh cs si east is on byte right higher and bh b and at bit and or bl bh mov bh mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di loop sol last byte is also special mov bl al is the assembl byte mov bh cs si maxbyt north is on line up lower and bh b and at bit and or bl bh or them into the assembl byte mov bh cs si maxbyt south is on line down higher and bh b and at bit and or bl bh place the stuff into al mov bh cs si west is on byte left lower and bh b and at bit and or bl bh mov bh cs si maxbyt east is on byte right higher and bh b and at bit and or bl bh mov bh mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di ret cs si sours of data cs di destin of data scanfirstlin first byte is a special case becaus of warparound mov bl mov bh cs si maxbyt lineno and bh b and at bit and or bl bh or them into the assembl byte mov bh cs si maxbyt and bh b and at bit and or bl bh place the stuff into al mov bh cs si maxbyt west is on byte left lower and bh b and at bit and or bl bh mov bh cs si east is on byte right higher and bh b and at bit and or bl bh mov bh mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di middl byte can be handl in a loop mov cx maxbyt sfl mov bl al is the assembl byte mov bh cs si maxbyt lineno and bh b and at bit and or bl bh or them into the assembl byte mov bh cs si maxbyt and bh b and at bit and or bl bh place the stuff into al mov bh cs si west is on byte left lower and bh b and at bit and or bl bh mov bh cs si east is on byte right higher and bh b and at bit and or bl bh mov bh mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di loop sfl last byte is also special mov bl al is the assembl byte mov bh cs si maxbyt lineno and bh b and at bit and or bl bh or them into the assembl byte mov bh cs si maxbyt and bh b and at bit and or bl bh place the stuff into al mov bh cs si west is on byte left lower and bh b and at bit and or bl bh mov bh cs si maxbyt east is on byte right higher and bh b and at bit and or bl bh mov bh mov al byte ptr cs bx offset hpprule mov cs di al ret cs si sours of data cs di destin of data scanlastlin first byte is a special case becaus of warparound mov bl al is the assembl byte mov bh cs si maxbyt and bh b and at bit and or bl bh or them into the assembl byte mov bh cs si maxbyt lineno and bh b and at bit and or bl bh place the stuff into al mov bh cs si maxbyt west is on byte left lower and bh b and at bit and or bl bh mov bh cs si east is on byte right higher and bh b and at bit and or bl bh mov bh mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di middl byte can be handl in a loop mov cx maxbyt sll mov bl al is the assembl byte mov bh cs si maxbyt and bh b and at bit and or bl bh or them into the assembl byte mov bh cs si maxbyt lineno and bh b and at bit and or bl bh place the stuff into al mov bh cs si west is on byte left lower and bh b and at bit and or bl bh mov bh cs si east is on byte right higher and bh b and at bit and or bl bh mov bh mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di loop sll last byte is also special mov bl al is the assembl byte mov bh cs si maxbyt and bh b and at bit and or bl bh or them into the assembl byte mov bh cs si maxbyt lineno and bh b and at bit and or bl bh place the stuff into al mov bh cs si west is on byte left lower and bh b and at bit and or bl bh mov bh cs si maxbyt east is on byte right higher and bh b and at bit and or bl bh mov bh mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di ret invert all veloc in the ga invertal push bx push cx push si mov si cs srcptr mov bx mov cx lineno ia push cx mov cx maxbyt ia mov bl cs si mov al byte ptr cs bx offset wallrul mov cs si al inc si loop ia pop cx loop ia pop si pop cx pop bx ret iterateonc mov si cs srcptr mov di cs desptr mov cs srcptr di mov cs desptr si push si push di call scanfirstlin pop di pop si add si maxbyt add di maxbyt mov cx lineno dont scan first and last l push si push di push cx call scanonemiddlelin pop cx pop di pop si add si maxbyt add di maxbyt loop l push si push di call scanlastlin pop si pop di l ret iter hpp rule cx time iter push cx call iterateonc pop cx call showga loop iter ret iter hpp rule cx time iterateuntil mov si mov cx offset iu offset iu iu mov al byte ptr cs si offset iu xor byte ptr cs si offset iu al inc si loop iu iu call iterateonc call showga mov si cs srcptr mov cx maxbyt mov bx mov ah mov al iu mov bl byte ptr cs si mov dl byte ptr cs bx wallrul not ah xor dl ah and al dl inc si loop iu mov si mov cx offset iu offset iu iu mov ah byte ptr cs si offset iu and ah al xor byte ptr cs si offset iu ah inc si loop iu jmp iu iu mov ax offset iu push ax ret db dup h iu push ax push bx push cx push dx push ds mov ah mov dx cs msgptr int h pop ds pop dx pop cx pop bx pop ax ret db dup h msgptr dw offset msg msg db thi messag is print out by db code decrypt us data from the lattic db which wa appli to the decod routin db after everi time step db the decod function left the code unchang db except after the ga evolut had completelli db revers the thermal time equ repetit ar enough to equilibr the ga begin mov ax h mov bh mov dh mov dl mov cx int h mov ah mov bh mov dh mov dl int h call initga call showga mov ah int h push cx mov cx time call iter call invertal call showga mov ah int h cmp al jne begin mov si cs srcptr xor byte ptr cs si b begin mov cx time call iterateuntil call invertal call showga mov ax c h int h code end end start 